# 矩阵计算器 on FPGA

本项目在2025年12月17日答辩通过，基本完成所有要求，并且实现了若干bonus，其中有一些功能存在一些缺陷，但是接近满分。

## 项目概述

本项目为南方科技大学2025年秋数字逻辑课程项目-可交互矩阵计算器的代码仓库。本仓库包含了所有的源文件、用到的语法检查脚本、项目架构文件和原图片（用于课程提交）和拟采用的图形界面文件。本项目使用MIT协议开源。

**人工智能使用声明**：
- 本项目大量采用人工智能生成重复代码-人工调优debug的模式进行，由于项目中手动定义的宏以及各种状态机的设置过于繁琐，我们通常使用人工智能协助进行编写。在关键状态转移、计算流程中，主要采用人工手动编写。尤其是各类多路选择和模块连接的部分，由于不堪其扰，我们采用了人工智能协助连接-代码编写者review的模式，确保连线完全正确，同时避免了人工连接导致的各类问题。
- 本项目中，人工智能助手提供的使用BRAM优化，避免LUT综合爆炸的建议非常有效。我们基于上一个项目版本（使用DRAM）使用人工智能进行了完全重构并且debug。
- 本项目充分体现了人工智能的局限性：在大量的复杂Verilog中，人工智能助手往往会在完全不存在问题的地方过度检查，并且最后输出的结果往往不能解决问题，需要人工手动添加断点测试排除问题。

## TODOs（项目开发进程） 

- 将LUT储存变成用BRAM存储 √
- 实现主模式、子模式转换 √
- 按键消抖 √
- 实现UART通信 √
- 实现输入矩阵并存储 √
- 实现访问矩阵（通过BRAM）√
- 实现随机生成模式 √
- 实现计算模式和若干计算类型 √
- 完善设置模式 √
- 设计展示模式 (暂时留存不做了)
- 设计卷积操作 √
- 实现错误输入倒计时+再次正确输入恢复功能 √
- GUI （有一个框架，但是连接懒得做了，直接用助手算了）
- 流水线 （这玩意儿有必要用吗？）

## 项目架构

### 模式模块

- Matrix Calculator Top Optimized （用Bram重构以后的顶层模块）
- Compute Mode （计算模式）
- Input Mode （输入模式）
- Generate Mode （生成模式）
- Display Mode （展示模式，用于展示已有所有矩阵，未完成）
- Setting Mode （设置模式，允许用户自定义最大矩阵维度、值的大小、单个维度矩阵可存储的数量）

### 计算模块

- add （加法模式）
- transpose （转置模式）
- scalar_mul （标量乘法模式）
- mul （矩阵乘法模式）
- conv （卷积模式，具有特殊的工作流程，仅支持$3\times 3$卷积核）

### UART模块

- uart_module
- uart_rx
- uart_tx

### 功能模块

- display control （数码管和LED控制）
- ifsr_rng （多项式随机数生成器）
- matrix package （参数宏定义）
- bram memory （内存读写模块）
- matrix manager （矩阵维度信息、地址信息管理器，支持自动寻址查找）

## 一些细节说明

### 如何操作内存？

- 内存管理器只做一件事：读入地址，给出数据
- 矩阵管理器负责：储存矩阵的统计信息（行列维数、起始地址和结束地址），分配内存（找到一个空闲位置，就返回给模块，让模块去内存管理器存）
- 模块如果要存入数据，首先是启动Alloc阶段，挂起Alloc请求，模块等待内存分配；若分配成功，则将将要存储的地址返回，交给模块（这里是矩阵管理器和模块的交互），读入数据以后，进行一系列处理，然后模块用内存地址提交写入（这里是模块和内存管理器交互）

### 如何执行计算？

- 确定操作数矩阵的元素位置地址，访问然后寄存
- 确定内存写入段落，直接根据每一位的表达式计算结果，然后写入
- 计算逻辑大同小异，此处不再赘述

### 卷积如何实现？

- 注意，此处卷积是对于所有的像素均进行了处理，通过边界补零的方式进行填充，因此结果矩阵尺寸将与原来的矩阵相同
- 我们首先通过基础地址（段起始地址）、i和j计算出左上角的地址，然后通过acc暂存结果，不断累加得到一个位上的结果，写入内存（因为我们的数据在内存中线性排列，所以可以直接通过偏移计算得到其中任意一位的地址，这比使用二维存储更加方便）
- 用有符号寄存器计算row_idx和col_idx，如果越界，那么值为零。
- 这里的卷积包含了边缘的像素，例如对于左上角的像素而言，参与卷积的就是自身、下方、右方、右下的像素加权。

### 伪随机数？

- 使用线性反馈位移寄存器（LFSR）生成随机数（具体原理没了解）
- 通过一个随机种子起始进行迭代，然后取低四位作为输出（如果大于当前设定最大值，取模保证数值位置）

### 如何实现规格打印？

实际上非常简单，只需要打印一个数字，然后打印一个空格，通过计数器维护当前一行的数据，如果一行显示完毕，那么发送换行符（ASCII码），如是就可以实现数字之间有空格、行列分开的打印效果

### 如何实现倒计时？

当输入检测过程中，检测到数字超出范围，电路将error寄存器为非零数，顶层模块接收到报错之后，报错led点亮，顶层模块的计时器开始倒计时，如果直到倒计时没有正确输入，那么发送reset信号，将模块内部状态恢复到IDLE，清空暂存数据。

### 如何实现设置模式？

首先，顶层模块中包含了几个关键寄存器（矩阵最大维数、最大数值、同一维度最大矩阵数量、倒计时设置——config系列变量）。FPGA烧录之后，第一个时钟上升沿，rst_n = 0，所有参数被置为为matrix_pkg中的参数设置。后续进入setting之后，根据uart接收的数据，将寄存器中的值更改为用户定义的值。

### 如何实现多数码管显示？

通过两位数码管选择位，当选择位为“01”的时候，显示左边那一位；选择位为“10”的时候，显示左边那一位。我们以countdown为例，当处于“10”的时候，显示十位数，我们只需要计算出寄存器countdown_second的十位数，然后输入display_ctrl即可控制；“01”的时候同理，只需要使用一个选择器即可。

### 如何实现矩阵覆盖？

我们使用一个slot_age来记录每一个槽位的“年龄”，年龄越小，越应该被覆盖。每一次分配内存的时候，先检测是否达到了上限，并且事先保存年龄最大的矩阵，如果超出上限，那么就将年龄最大的矩阵的起始地址返回，写入的时候会自然覆盖这个矩阵（因为维度相同，不需要再次分配内存）

## 一些代码细节说明

### 线网和寄存器说明

#### 顶层模块

- main_state, main_state_next 主状态寄存器
- op_type_from_compute 从模块内取出计算类型，方便退出其中一个计算模式
- active系列变量 模块激活信号
- 配置系列变量config_setting 由setting模式控制，初始化配置为默认值，后续可自由配置
- 组合逻辑config：将setting中的信号寄存起来，传输给其他模块
- uart接口
- 内存读写寄存器：读写使能、写入使能、地址和输入输出（din表示数据写入线路，dout表示读出数据线路）
- 数据多路选择信号：分配申请、分配维度信息、分配槽位、分配地址、分配valid信号；查询信号，查询维度和查询槽号，查询valid信号；存入信号commit系列（表明写入完成，commit的全部内容记录进入matrix_manager，若失败，则不会存入内存；未来，可以增加写入失败自动回滚的机制）
- 随机数寄存器（来自线性反馈位移寄存器）
- 来自各模式的错误码，错误led灯信号；倒计时寄存器，倒计时秒数控制，十位和个位分别存储
- 子状态信号寄存
- 多路选择逻辑：通过激活信号控制多模块信号，防止multidriver（后续的地址也是同理的）
- 主状态机，通过拨码开关控制主状态机；处于计算模式的时候，若内部状态处于1（SELECT_OP），那么可以返回主菜单；如果不是，等内部归位以后，如果再次按下按钮再退出；方便连续在模式内部进行计算
- substate用于读取内部的状态细节，方便输出错误（实际上在本项目中没有太大用处）
- 计时器，用两个信号输入显示控制器，方便用两个数码管显示倒计时（如果进入错误模式，那么开始倒计时；结束倒计时之后，发送timeout信号重置模块内部状态）
- 若干实例化

#### 输入模式和生成模式（唯一区别是数据来源）

- 输入数字：通过寄存器积累读入两位数字；并且通过读入顶层模块的最大维度设置，进行错误检验
- 等待分配：发起内存分配请求和矩阵数据，得到分配数据；若分配失败，可以考虑进入错误状态。因为没有要求所以没做。
- 解析数字，如有错误，那么将会进入错误状态
- 如果输入的数字不足，那么自动写入0直到计数器到达要求的元素数量
- 如果多余，自动截断
- Commit，将数据写入内存，地址信息写入matrix_manager
- 展示模式：规格化打印字符，根据刚刚分配的地址读取内存中的数据，检查是否正确写入了数据
- 对于生成模式，增加了一个矩阵数量计数器，如果不足，回到ALLOC状态

#### 消抖

- 一个10ms的倒计时，用来检测确实产生了一个上升电平，然后在下降沿产生脉冲

#### BRAM POOL

这是一个很简单的写入和读取控制：使能为1、读入地址，写入数据；使能为1，读入地址，读取数据，传出数据

ramstyle用来控制综合的时候的风格，保证使用bram以减少LUT使用。

#### MATRIX MANAGER

考虑到地址数据并不多，因此使用DRAM储存，ramstyle为distributed

- matrix valid标记槽位是否可用
- rows存储行，对应槽位
- col存储列，对应槽位
- start_addr 存储矩阵开始的地址，end_addr记录矩阵结束的地址
- slot_age用来存储矩阵的年龄，我们永远使用最年老的矩阵进行覆写
- global_age_counter存储全局年龄，方便给新来的矩阵分配年龄
- 5B最大矩阵限制配置，防止配置的最大矩阵数超过实际限制
- query通过地址读取manager内部数据

分配逻辑如下：
- 申请暂存变量
- 如果接收到了分配请求，那么计算分配的位置数量；
- 计数已经存储同维度矩阵的数量，防止超出限制
- 从小槽位开始向大的遍历，直到找到合法的
- 检查末端地址，然后返回上一个矩阵的末尾的后一个地址作为新的地址
- 如果统计到同维度矩阵过多，那么就根据前面统计到的最年老的矩阵开始替换（直接返回这个矩阵的地址，因为维度相同，不需要重新计算元素数量）
- 写入完毕，commit，将地址、valid、行列记录在manager中，以便下次利用

也就是说，我们只需要使用槽位就可以访问矩阵的所有内容，这提高了效率。

#### COMPUTE MODE

- 按下按键，进入对应的计算模式；
- 计算valid槽位的数量，然后打印数量
- 遍历所有的矩阵维度组合，打印所有的统计信息（耗时比较久），然后计数
- 输入矩阵维度，然后遍历，打印符合要求的矩阵的信息
- 输入当前的索引，然后再次遍历，找到索引所引的槽号，然后记录到op1中；同样，重复一遍（如果需要第二个操作数）
- 打印操作数，按下确认，进行计算
- 如果是卷积，那么选择矩阵，然后给出所有的3乘3卷积核，然后选择，按下按钮进行计算

#### 线性反馈位移寄存器

我们通过LFSR生成随机数序列，通过反馈多项式和位移来生成随机数字

#### 计算方法

- 根据计算的性质，计算出需要分配的内存，然后将结果写入内存，对于每一个地址，我们在一个循环中计算出地址上应该写入的数据，然后直接写入
- 计算完毕以后，根据地址打印矩阵

### 计算实现

- 加法：读取对应坐标上的两个数字，然后相加，写入内存
- 标量乘法同理
- 转置：顺序读取，然后写入内存中对称位置的内存（start+j*dim_m + i）
- 乘法：读取（addr_op1 + (i\*dim_p + k), addr_op2 + (k\*dim) + j）, 然后k++，累加到位置里面
- 卷积：同理，每一个i，j变化，我们通过ki和kj访问op2，计算偏置（例如，是左上角，我们通过row_idx，col_idx存储出对应的地址偏移），然后计算出大矩阵此时需要读取的地址，累加结果直到9个数字都被累加完毕


### 语法说明

- (DONT_TOUCH): 强制综合器不要优化掉此变量，防止出现问题
- 