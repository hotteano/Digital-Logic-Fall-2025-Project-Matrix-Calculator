# 矩阵计算器 on FPGA

## 项目概述

本项目为南方科技大学2025年秋数字逻辑课程项目-可交互矩阵计算器的代码仓库。本仓库包含了所有的源文件、用到的语法检查脚本、项目架构文件和原图片（用于课程提交）和拟采用的图形界面文件。本项目使用MIT协议开源。

**人工智能使用声明**：
- 本项目大量采用人工智能生成重复代码-人工调优debug的模式进行，由于项目中手动定义的宏以及各种状态机的设置过于繁琐，我们通常使用人工智能协助进行编写。在关键状态转移、计算流程中，主要采用人工手动编写。尤其是各类多路选择和模块连接的部分，由于不堪其扰，我们采用了人工智能协助连接-代码编写者review的模式，确保连线完全正确，同时避免了人工连接导致的各类问题。
- 本项目中，人工智能助手提供的使用BRAM优化，避免LUT综合爆炸的建议非常有效。我们基于上一个项目版本（使用DRAM）使用人工智能进行了完全重构并且debug。
- 本项目充分体现了人工智能的局限性：在大量的复杂Verilog中，人工智能助手往往会在完全不存在问题的地方过度检查，并且最后输出的结果往往不能解决问题，需要人工手动添加断点测试排除问题。

## TODOs（项目开发进程） 

- 将LUT储存变成用BRAM存储 √
- 实现主模式、子模式转换 √
- 按键消抖 √
- 实现UART通信 √
- 实现输入矩阵并存储 √
- 实现访问矩阵（通过BRAM）√
- 实现随机生成模式 √
- 实现计算模式和若干计算类型 √
- 完善设置模式 √
- 设计展示模式 (暂时留存不做了)
- 设计卷积操作 √
- 实现错误输入倒计时+再次正确输入恢复功能 √
- GUI （有一个框架，但是连接懒得做了，直接用助手算了）
- 流水线 （这玩意儿有必要用吗？）

## 项目架构

### 模式模块

- Matrix Calculator Top Optimized （用Bram重构以后的顶层模块）
- Compute Mode （计算模式）
- Input Mode （输入模式）
- Generate Mode （生成模式）
- Display Mode （展示模式，用于展示已有所有矩阵，未完成）
- Setting Mode （设置模式，允许用户自定义最大矩阵维度、值的大小、单个维度矩阵可存储的数量）

### 计算模块

- add （加法模式）
- transpose （转置模式）
- scalar_mul （标量乘法模式）
- mul （矩阵乘法模式）
- conv （卷积模式，具有特殊的工作流程，仅支持$3\times 3$卷积核）

### UART模块

- uart_module
- uart_rx
- uart_tx

### 功能模块

- display control （数码管和LED控制）
- ifsr_rng （多项式随机数生成器）
- matrix package （参数宏定义）
- bram memory （内存读写模块）
- matrix manager （矩阵维度信息、地址信息管理器，支持自动寻址查找）

## 一些细节说明

### 如何操作内存？

- 内存管理器只做一件事：读入地址，给出数据
- 矩阵管理器负责：储存矩阵的统计信息（行列维数、起始地址和结束地址），分配内存（找到一个空闲位置，就返回给模块，让模块去内存管理器存）
- 模块如果要存入数据，首先是启动Alloc阶段，挂起Alloc请求，模块等待内存分配；若分配成功，则将将要存储的地址返回，交给模块（这里是矩阵管理器和模块的交互），读入数据以后，进行一系列处理，然后模块用内存地址提交写入（这里是模块和内存管理器交互）

### 如何执行计算？

- 确定操作数矩阵的元素位置地址，访问然后寄存
- 确定内存写入段落，直接根据每一位的表达式计算结果，然后写入
- 计算逻辑大同小异，此处不再赘述

### 卷积如何实现？

- 注意，此处卷积是对于所有的像素均进行了处理，通过边界补零的方式进行填充，因此结果矩阵尺寸将与原来的矩阵相同
- 我们首先通过基础地址（段起始地址）、i和j计算出左上角的地址，然后通过acc暂存结果，不断累加得到一个位上的结果，写入内存（因为我们的数据在内存中线性排列，所以可以直接通过偏移计算得到其中任意一位的地址，这比使用二维存储更加方便）
- 用有符号寄存器计算row_idx和col_idx，如果越界，那么值为零。
- 这里的卷积包含了边缘的像素，例如对于左上角的像素而言，参与卷积的就是自身、下方、右方、右下的像素加权。

### 伪随机数？

- 使用线性反馈位移寄存器（LFSR）生成随机数（具体原理没了解）
- 通过一个随机种子起始进行迭代，然后取低四位作为输出（如果大于当前设定最大值，取模保证数值位置）

### 如何实现规格打印？

实际上非常简单，只需要打印一个数字，然后打印一个空格，通过计数器维护当前一行的数据，如果一行显示完毕，那么发送换行符（ASCII码），如是就可以实现数字之间有空格、行列分开的打印效果

### 如何实现倒计时？

当输入检测过程中，检测到数字超出范围，电路将error寄存器为非零数，顶层模块接收到报错之后，报错led点亮，顶层模块的计时器开始倒计时，如果直到倒计时没有正确输入，那么发送reset信号，将模块内部状态恢复到IDLE，清空暂存数据。

### 如何实现设置模式？

首先，顶层模块中包含了几个关键寄存器（矩阵最大维数、最大数值、同一维度最大矩阵数量、倒计时设置——config系列变量）。FPGA烧录之后，第一个时钟上升沿，rst_n = 0，所有参数被置为为matrix_pkg中的参数设置。后续进入setting之后，根据uart接收的数据，将寄存器中的值更改为用户定义的值。

### 如何实现多数码管显示？

通过两位数码管选择位，当选择位为“01”的时候，显示左边那一位；选择位为“10”的时候，显示左边那一位。我们以countdown为例，当处于“10”的时候，显示十位数，我们只需要计算出寄存器countdown_second的十位数，然后输入display_ctrl即可控制；“01”的时候同理，只需要使用一个选择器即可。

### 如何实现矩阵覆盖？

我们使用一个slot_age来记录每一个槽位的“年龄”，年龄越小，越应该被覆盖。每一次分配内存的时候，先检测是否达到了上限，并且事先保存年龄最大的矩阵，如果超出上限，那么就将年龄最大的矩阵的起始地址返回，写入的时候会自然覆盖这个矩阵（因为维度相同，不需要再次分配内存）

