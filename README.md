# 矩阵计算器 on FPGA

## 项目概述

本项目为南方科技大学2025年秋数字逻辑课程项目-可交互矩阵计算器的代码仓库。本仓库包含了所有的源文件、用到的语法检查脚本、项目架构文件和原图片（用于课程提交）和拟采用的图形界面文件。本项目使用MIT协议开源。

**人工智能使用声明**：
- 本项目大量采用人工智能生成重复代码-人工调优debug的模式进行，由于项目中手动定义的宏以及各种状态机的设置过于繁琐，我们通常使用人工智能协助进行编写。在关键状态转移、计算流程中，主要采用人工手动编写。尤其是各类多路选择和模块连接的部分，由于不堪其扰，我们采用了人工智能协助连接-代码编写者review的模式，确保连线完全正确，同时避免了人工连接导致的各类问题。
- 本项目中，人工智能助手提供的使用BRAM优化，避免LUT综合爆炸的建议非常有效。我们基于上一个项目版本（使用DRAM）使用人工智能进行了完全重构并且debug。
- 本项目充分体现了人工智能的局限性：在大量的复杂Verilog中，人工智能助手往往会在完全不存在问题的地方过度检查，并且最后输出的结果往往不能解决问题，需要人工手动添加断点测试排除问题。

## TODOs（项目开发进程） 

- 将LUT储存变成用BRAM存储 √
- 实现主模式、子模式转换 √
- 按键消抖 √
- 实现UART通信 √
- 实现输入矩阵并存储 √
- 实现访问矩阵（通过BRAM）√
- 实现随机生成模式 √
- 实现计算模式和若干计算类型 √
- 完善设置模式 √
- 设计展示模式 (暂时留存不做了)
- 设计卷积操作 √
- 实现错误输入倒计时+再次正确输入恢复功能 √
- GUI （有一个框架，但是连接懒得做了，直接用助手算了）
- 流水线 （这玩意儿有必要用吗？）

## 项目架构

### 模式模块

- Matrix Calculator Top Optimized （用Bram重构以后的顶层模块）
- Compute Mode （计算模式）
- Input Mode （输入模式）
- Generate Mode （生成模式）
- Display Mode （展示模式，用于展示已有所有矩阵，未完成）
- Setting Mode （设置模式，允许用户自定义最大矩阵维度、值的大小、单个维度矩阵可存储的数量）

### 计算模块

- add （加法模式）
- transpose （转置模式）
- scalar_mul （标量乘法模式）
- mul （矩阵乘法模式）
- conv （卷积模式，具有特殊的工作流程，仅支持$3\times 3$卷积核）

### UART模块

- uart_module
- uart_rx
- uart_tx

### 功能模块

- display control （数码管和LED控制）
- ifsr_rng （多项式随机数生成器）
- matrix package （参数宏定义）
- bram memory （内存读写模块）
- matrix manager （矩阵维度信息、地址信息管理器，支持自动寻址查找）

## 一些细节说明

### 如何操作内存？

- 内存管理器只做一件事：读入地址，给出数据
- 矩阵管理器负责：储存矩阵的统计信息（行列维数、起始地址和结束地址），分配内存（找到一个空闲位置，就返回给模块，让模块去内存管理器存）
- 模块如果要存入数据，首先是启动Alloc阶段，挂起Alloc请求，模块等待内存分配；若分配成功，则将将要存储的地址返回，交给模块（这里是矩阵管理器和模块的交互），读入数据以后，进行一系列处理，然后模块用内存地址提交写入（这里是模块和内存管理器交互）

### 如何执行计算？

- 确定操作数矩阵的元素位置地址，访问然后寄存
- 确定内存写入段落，直接根据每一位的表达式计算结果，然后写入
- 计算逻辑大同小异，此处不再赘述

### 卷积如何实现？

- 注意，此处卷积是对于所有的像素均进行了处理，通过边界补零的方式进行填充，因此结果矩阵尺寸将与原来的矩阵相同
- 我们首先通过基础地址（段起始地址）、i和j计算出左上角的地址，然后通过acc暂存结果，不断累加得到一个位上的结果，写入内存（因为我们的数据在内存中线性排列，所以可以直接通过偏移计算得到其中任意一位的地址，这比使用二维存储更加方便）
- 用有符号寄存器计算row_idx和col_idx，如果越界，那么值为零。
- 这里的卷积包含了边缘的像素，例如对于左上角的像素而言，参与卷积的就是自身、下方、右方、右下的像素加权。

### 伪随机数？

- 使用多项式生成